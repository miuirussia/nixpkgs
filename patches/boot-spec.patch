diff --git a/.github/CODEOWNERS b/.github/CODEOWNERS
index 557542772cf7c..011a22c739a0f 100644
--- a/.github/CODEOWNERS
+++ b/.github/CODEOWNERS
@@ -71,6 +71,7 @@
 /nixos/doc/manual/man-nixos-option.xml                @nbp
 /nixos/modules/installer/tools/nixos-option.sh        @nbp
 /nixos/modules/system                                 @dasJ
+/nixos/modules/system/activation/boot-spec.nix        @grahamc @cole-h
 
 # NixOS integration test driver
 /nixos/lib/test-driver  @tfc
diff --git a/nixos/modules/module-list.nix b/nixos/modules/module-list.nix
index 81b3869997033..da9159375664d 100644
--- a/nixos/modules/module-list.nix
+++ b/nixos/modules/module-list.nix
@@ -1179,6 +1179,7 @@
   ./system/boot/loader/grub/grub.nix
   ./system/boot/loader/grub/ipxe.nix
   ./system/boot/loader/grub/memtest.nix
+  ./system/boot/loader/manual/manual.nix
   ./system/boot/loader/init-script/init-script.nix
   ./system/boot/loader/loader.nix
   ./system/boot/loader/raspberrypi/raspberrypi.nix
diff --git a/nixos/modules/system/activation/boot-spec.nix b/nixos/modules/system/activation/boot-spec.nix
new file mode 100644
index 0000000000000..fa3583ecbf79e
--- /dev/null
+++ b/nixos/modules/system/activation/boot-spec.nix
@@ -0,0 +1,47 @@
+{ config, pkgs, lib, children }:
+let
+  schemas = {
+    v1 = rec {
+      filename = "boot.v1.json";
+      json =
+        pkgs.writeText filename
+          (builtins.toJSON
+            {
+              schemaVersion = 1;
+
+              kernel = "${config.boot.kernelPackages.kernel}/${config.system.boot.loader.kernelFile}";
+              kernelParams = config.boot.kernelParams;
+              kernelVersion = config.boot.kernelPackages.kernel.modDirVersion;
+              initrd = "${config.system.build.initialRamdisk}/${config.system.boot.loader.initrdFile}";
+              initrdSecrets = "${config.system.build.initialRamdiskSecretAppender}/bin/append-initrd-secrets";
+              systemVersion = config.system.nixos.label;
+
+              specialisation = lib.mapAttrs
+                (childName: childToplevel: {
+                  bootspec = "${childToplevel}/${filename}";
+                  toplevel = childToplevel;
+                })
+                children;
+            });
+
+      generator = ''
+        ${pkgs.jq}/bin/jq '
+          .toplevel = $toplevel |
+          .init = $init
+          ' \
+          --sort-keys \
+          --arg toplevel "$out" \
+          --arg init "$out/init" \
+          < ${json} \
+          > $out/${filename}
+      '';
+    };
+  };
+in
+{
+  # This will be run as a part of the `systemBuilder` in ./top-level.nix. This
+  # means `$out` points to the output of `config.system.build.toplevel` and can
+  # be used for a variety of things (though, for now, it's only used to report
+  # the path of the `toplevel` itself and the `init` executable).
+  writer = schemas.v1.generator;
+}
diff --git a/nixos/modules/system/activation/top-level.nix b/nixos/modules/system/activation/top-level.nix
index 84f560691fc4d..63f4fcd2e7c18 100644
--- a/nixos/modules/system/activation/top-level.nix
+++ b/nixos/modules/system/activation/top-level.nix
@@ -22,6 +22,14 @@ let
         "${config.system.boot.loader.kernelFile}";
       initrdPath = "${config.system.build.initialRamdisk}/" +
         "${config.system.boot.loader.initrdFile}";
+
+      bootSpec = import ./boot-spec.nix {
+        inherit
+          config
+          pkgs
+          lib
+          children;
+      };
     in ''
       mkdir $out
 
@@ -95,6 +103,8 @@ let
 
       echo -n "${toString config.system.extraDependencies}" > $out/extra-dependencies
 
+      ${bootSpec.writer}
+
       ${config.system.extraSystemBuilderCmds}
     '';
 
diff --git a/nixos/modules/system/boot/loader/manual/manual.nix b/nixos/modules/system/boot/loader/manual/manual.nix
new file mode 100644
index 0000000000000..99232361e004b
--- /dev/null
+++ b/nixos/modules/system/boot/loader/manual/manual.nix
@@ -0,0 +1,42 @@
+{ config, lib, pkgs, ... }:
+
+with lib;
+
+let
+  cfg = config.boot.loader.manual;
+
+  manualInstaller = pkgs.writeShellScript "manual-bootloader-installer" ''
+    cat <<EOT
+    OK, you may update your bootloader now!
+    $1
+    EOT
+  '';
+in
+{
+  # TODO: boot loader hook and rename option from manual to something more fitting
+  options.boot.loader.manual = {
+    enable = mkEnableOption "manual configuration of the bootloader";
+
+    installHook = mkOption {
+      type = with types; nullOr package;
+      default = null;
+      description = ''
+        A shell script that will be run as part of the bootloader installation process.
+        Use <code>writeShellScript</code>, and <code>$1</code> may be used to refer to the output of the system's toplevel.
+      '';
+    };
+  };
+
+  config = mkIf cfg.enable {
+    boot.loader = {
+      grub.enable = mkDefault false;
+      systemd-boot.enable = mkDefault false;
+      supportsInitrdSecrets = false;
+    };
+
+    # FIXME: this means vmWithBootLoader will hang / not work. maybe if
+    # `config.virtualisation.useBootLoader` is true, give instructions on how to
+    # build a boot disk image for the VM?
+    system.build.installBootLoader = if (cfg.installHook != null) then cfg.installHook else manualInstaller;
+  };
+}
